import xml.etree.ElementTree as ET
from vaspwfc import vaspwfc
import numpy as np

"""
Here there are some tools for defect class
"""
def get_ion_orbital_total_weight_neighbors_to_defects(
        vasprun_path: str,
        ion_neighbor_indeces_to_defects: int,
        norm: bool = False,
        ) -> dict:
    
    """
    Extracts the orbital weights of ions from a VASP `vasprun.xml` file for a specified set of neighbors.

    Parameters:
    ----------
    vasprun_path : str
        Path to the `vasprun.xml` file generated by VASP. This file contains data about the electronic structure.

    ion_neighbor_indeces_to_defects : int
        The indices of neighboring ions around the defect site to be considered in the orbital weight calculation.
        This allows focusing on the most localized states related to the defect.
    
    norm : bool, optional
        If True, normalizes the weights by the total weight for each k-point. Defaults to False.

    Returns:
    -------
    dict
        A nested dictionary structure where:
        - The top-level keys are spins (`'spin1'` for spin-up and `'spin2'` for spin-down).
        - The second-level keys are k-points (e.g., `'kpoint 1'`, `'kpoint 2'`).
        - The values are lists of summed orbital weights for the specified neighbor indices.

    Example Output:
    --------------
    weights = get_ion_orbitals_total_weight("vasprun.xml", [0, 1, 2])
    print(weights['spin1']['kpoint 1'])
    >>> [282.067, 295.8235, 218.1941, ...]

    Notes:
    ------
    - This function computes the total orbital weight for ions at each k-point and spin.
    - The most localized states are identified by focusing on neighboring ions instead of all ions, 
      which might dilute the localization effect if averaged over the entire supercell.
    - The orbital weights for each ion include contributions from all orbitals (s, p, d, f).
    """

    # Load the `vasprun.xml` file using XML parsing
    tree = ET.parse(vasprun_path)
    root = tree.getroot()

    # Initialize the weight dictionary
    weights = {}

    # Loop over spins ('spin1' for spin-up, 'spin2' for spin-down)
    for spin in root.findall(".//set[@comment='spin1']") + root.findall(".//set[@comment='spin2']"):
        spin_key = spin.attrib['comment']  # Extract spin type (e.g., 'spin1')
        weights[spin_key] = {}

        # Loop over k-points in the current spin
        for kpoint_index, kpoint_set in enumerate(spin.findall("set")):
            kpoint_key = f"kpoint {kpoint_index + 1}"  # Label k-point as 'kpoint 1', 'kpoint 2', etc.
            weights[spin_key][kpoint_key] = []

            # Loop over bands for the current k-point
            for band in kpoint_set.findall(".//set"):
                # List to hold orbital weights for all ions in the band
                ions_obital_total_weights = []

                # Loop over orbital weights for each ion (s, p, d, f contributions)
                for r in band.findall(".//r"):
                    ion_orbital_s_p_d_f_weight = map(float, r.text.split())
                    ion_obital_total_weight = sum(ion_orbital_s_p_d_f_weight)  # Total weight for the ion
                    ions_obital_total_weights.append(ion_obital_total_weight)

                # Sum the orbital weights for the specified neighbor indices
                ions_obital_total_weight_around_defect = 0
                for ion_index in ion_neighbor_indeces_to_defects:
                    ions_obital_total_weight_around_defect += ions_obital_total_weights[ion_index]

                # Append the result for each band
                weights[spin_key][kpoint_key].append(ions_obital_total_weight_around_defect)
    if norm:
        # Normalize weights at the end
        for spin_key, kpoint_data in weights.items():
            for kpoint_key, band_weights in kpoint_data.items():
                total_weight_kpoint = sum(band_weights)  # Total weight for the k-point
                if total_weight_kpoint > 0:
                    # Normalize each band's weight by the total k-point weight
                    weights[spin_key][kpoint_key] = [weight / total_weight_kpoint for weight in band_weights]
                else:
                    # Handle the zero-weight case: raise a clear error
                    raise ValueError(
                        f"Total weight for {spin_key} at {kpoint_key} is zero. Check the input data or ion indices."
                    )
    return weights


def get_ipr_values(WAVECAR_path:str,
                   lsorbit:bool=False, 
                   lgamma:bool=False,
                   gamma_half:str='x', 
                   omp_num_threads:int=1,
                   **settings):
    
    '''
    Calculate the Inverse Participation Ratio (IPR) for each band, k-point, and spin from a WAVECAR file.

    Parameters:
    -----------
    WAVECAR_path : str
        The path to the WAVECAR file containing the wavefunction data.
    
    lsorbit : bool, optional, default=False
        If True, includes the orbital angular momentum in the wavefunction calculation.
    
    lgamma : bool, optional, default=False
        If True, includes the Gamma point in the calculations.
    
    gamma_half : str, optional, default='x'
        Specifies the Gamma half-point calculation ('x' is the default value).
    
    omp_num_threads : int, optional, default=1
        The number of OpenMP threads to use for parallel computation.
    
    settings:   
    gvec : the G-vectors correspond to the plane-wave coefficients
    Cg : the plane-wave coefficients. If None, read from WAVECAR
    ngrid : the FFT grid size
    norm : normalized Cg?
    kr_phase : whether or not to multiply the exp(ikr) phase
    r0 : shift of the kr-phase to get full wfc other than primitive cell

    Returns:
    --------    
    dict
        A dictionary with the IPR values for each spin, k-point, and band {spin: {kpoint index: [band1 band2 ...]}}.
        Where each band has its IPR value.
    
    Note:
    -----
    This function uses the `vaspwfc` class from the `VaspBandUnfolding` library (https://github.com/QijingZheng/VaspBandUnfolding.git) to read the WAVECAR file and extract wavefunction data.
    '''
    r"""
    IPR definition:

                    \sum_n |\phi_j(n)|^4 
    IPR(\phi_j) = -------------------------
                  |\sum_n |\phi_j(n)|^2||^2

   The normalizatition is defined:

    \sum_{ijk} | \phi_{ijk} | ^ 2 = 1
    
    """    
    # Create an instance of vaspwfc
    read_vasp_wf = vaspwfc(fnm=WAVECAR_path,
                           lsorbit=lsorbit, 
                           lgamma=lgamma,
                           gamma_half=gamma_half, 
                           omp_num_threads=omp_num_threads
                           )

    # Initialize a dictionary to store IPR data
    ipr_values = {}

    # Loop over k-points, bands, and spins (assuming the WAVECAR contains this information)
    for spin in range(read_vasp_wf._nspin): 
        ipr_values[f'spin{spin}'] = {}

        for k_index in range(read_vasp_wf._nkpts):
            ipr_values[f'spin{spin}'][f"kpoint {k_index}"] = []

            for band_index in range(read_vasp_wf._nbands):
                # Get the real-space wavefunction
                phi_j = read_vasp_wf.wfc_r(ispin=spin+1, ikpt=k_index+1, iband=band_index+1,**settings)

                phi_j_abs = np.abs(phi_j)

                # Calculate the IPA for each band 
                ipr= np.sum(phi_j_abs**4) / np.sum(phi_j_abs**2)**2

                # Store the IPR in the dictionary
                ipr_values[f'spin{spin}'][f"kpoint {k_index}"].append(ipr)

    return ipr_values